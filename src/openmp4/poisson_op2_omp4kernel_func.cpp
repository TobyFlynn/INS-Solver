//
// auto-generated by op2.py
//

void poisson_op2_omp4_kernel(
  int *data0,
  int dat0size,
  bool *data1,
  int dat1size,
  int *map2,
  int map2size,
  double *data30,
  int dat30size,
  double *data31,
  int dat31size,
  double *data2,
  int dat2size,
  double *data4,
  int dat4size,
  double *data6,
  int dat6size,
  double *data8,
  int dat8size,
  double *data10,
  int dat10size,
  double *data12,
  int dat12size,
  double *data14,
  int dat14size,
  double *data16,
  int dat16size,
  double *data18,
  int dat18size,
  double *data20,
  int dat20size,
  double *data22,
  int dat22size,
  double *data24,
  int dat24size,
  double *data26,
  int dat26size,
  double *data28,
  int dat28size,
  int *col_reord,
  int set_size1,
  int start,
  int end,
  int num_teams,
  int nthread){

  #pragma omp target teams num_teams(num_teams) thread_limit(nthread) map(to:data0[0:dat0size],data1[0:dat1size],data30[0:dat30size],data31[0:dat31size]) \
    map(to: gaussW_g_ompkernel[:7], gFInterp0_g_ompkernel[:105], gFInterp1_g_ompkernel[:105], gFInterp2_g_ompkernel[:105])\
    map(to:col_reord[0:set_size1],map2[0:map2size],data2[0:dat2size],data4[0:dat4size],data6[0:dat6size],data8[0:dat8size],data10[0:dat10size],data12[0:dat12size],data14[0:dat14size],data16[0:dat16size],data18[0:dat18size],data20[0:dat20size],data22[0:dat22size],data24[0:dat24size],data26[0:dat26size],data28[0:dat28size])
  #pragma omp distribute parallel for schedule(static,1)
  for ( int e=start; e<end; e++ ){
    int n_op = col_reord[e];
    int map2idx;
    int map3idx;
    map2idx = map2[n_op + set_size1 * 0];
    map3idx = map2[n_op + set_size1 * 1];

    //variable mapping
    const int *edgeNum = &data0[2*n_op];
    const bool *rev = &data1[1*n_op];
    const double *mD0L = &data2[105 * map2idx];
    const double *mD0R = &data2[105 * map3idx];
    const double *mD1L = &data4[105 * map2idx];
    const double *mD1R = &data4[105 * map3idx];
    const double *mD2L = &data6[105 * map2idx];
    const double *mD2R = &data6[105 * map3idx];
    const double *pD0L = &data8[105 * map2idx];
    const double *pD0R = &data8[105 * map3idx];
    const double *pD1L = &data10[105 * map2idx];
    const double *pD1R = &data10[105 * map3idx];
    const double *pD2L = &data12[105 * map2idx];
    const double *pD2R = &data12[105 * map3idx];
    const double *gVP0L = &data14[105 * map2idx];
    const double *gVP0R = &data14[105 * map3idx];
    const double *gVP1L = &data16[105 * map2idx];
    const double *gVP1R = &data16[105 * map3idx];
    const double *gVP2L = &data18[105 * map2idx];
    const double *gVP2R = &data18[105 * map3idx];
    const double *sJL = &data20[21 * map2idx];
    const double *sJR = &data20[21 * map3idx];
    const double *hL = &data22[1 * map2idx];
    const double *hR = &data22[1 * map3idx];
    const double *gFactorL = &data24[21 * map2idx];
    const double *gFactorR = &data24[21 * map3idx];
    const double *factorL = &data26[15 * map2idx];
    const double *factorR = &data26[15 * map3idx];
    double *op1L = &data28[225 * map2idx];
    double *op1R = &data28[225 * map3idx];
    double *op2L = &data30[225*n_op];
    double *op2R = &data31[225*n_op];

    //inline function
    

    int edgeL = edgeNum[0];
    int edgeR = edgeNum[1];
    bool reverse = *rev;


    const double *mDL, *mDR, *pDL, *pDR, *gVML, *gVMR, *gVPL, *gVPR;
    if(edgeL == 0) {
      mDL  = mD0L;
      pDL  = pD0L;
      gVML = gFInterp0_g_ompkernel;
      gVPL = gVP0L;
    } else if(edgeL == 1) {
      mDL  = mD1L;
      pDL  = pD1L;
      gVML = gFInterp1_g_ompkernel;
      gVPL = gVP1L;
    } else {
      mDL  = mD2L;
      pDL  = pD2L;
      gVML = gFInterp2_g_ompkernel;
      gVPL = gVP2L;
    }

    if(edgeR == 0) {
      mDR  = mD0R;
      pDR  = pD0R;
      gVMR = gFInterp0_g_ompkernel;
      gVPR = gVP0R;
    } else if(edgeR == 1) {
      mDR  = mD1R;
      pDR  = pD1R;
      gVMR = gFInterp1_g_ompkernel;
      gVPR = gVP1R;
    } else {
      mDR  = mD2R;
      pDR  = pD2R;
      gVMR = gFInterp2_g_ompkernel;
      gVPR = gVP2R;
    }



    for(int i = 0; i < 15; i++) {
      for(int j = 0; j < 15; j++) {
        int c_ind = i * 15 + j;
        op2L[c_ind] = 0.0;
        op2R[c_ind] = 0.0;
        for(int k = 0; k < 7; k++) {

          int b_ind = k * 15 + j;

          int ind = i * 7 + k;
          int a_ind = ((ind * 15) % (15 * 7)) + (ind / 7);


          int factors_indL = edgeL * 7 + k;
          int factors_indR = edgeR * 7 + k;
          int factors_indLR;
          int factors_indRR;
          if(reverse) {
            factors_indLR = edgeL * 7 + 6 - k;
            factors_indRR = edgeR * 7 + 6 - k;
          } else {
            factors_indLR = edgeL * 7 + k;
            factors_indRR = edgeR * 7 + k;
          }

          op1L[c_ind] += -0.5 * gVML[a_ind] * gaussW_g_ompkernel[k] * sJL[factors_indL]
                         * gFactorL[factors_indL] * mDL[b_ind];
          op1R[c_ind] += -0.5 * gVMR[a_ind] * gaussW_g_ompkernel[k] * sJR[factors_indR]
                         * gFactorR[factors_indR] * mDR[b_ind];

          op2L[c_ind] += -0.5 * gVML[a_ind] * gaussW_g_ompkernel[k] * sJL[factors_indL]
                         * gFactorR[factors_indRR] * pDL[b_ind];
          op2R[c_ind] += -0.5 * gVMR[a_ind] * gaussW_g_ompkernel[k] * sJR[factors_indR]
                         * gFactorL[factors_indLR] * pDR[b_ind];
        }
      }
    }



    for(int i = 0; i < 15; i++) {
      for(int j = 0; j < 15; j++) {
        int c_ind = i * 15 + j;
        for(int k = 0; k < 7; k++) {

          int b_ind = k * 15 + j;

          int ind = i * 7 + k;
          int a_ind = ((ind * 15) % (15 * 7)) + (ind / 7);

          int factors_indL = edgeL * 7 + k;
          int factors_indR = edgeR * 7 + k;

          op1L[c_ind] += -factorL[i] * mDL[a_ind] * gaussW_g_ompkernel[k]
                         * sJL[factors_indL] * gVML[b_ind];
          op1R[c_ind] += -factorR[i] * mDR[a_ind] * gaussW_g_ompkernel[k]
                         * sJR[factors_indR] * gVMR[b_ind];

          op2L[c_ind] += factorL[i] * mDL[a_ind] * gaussW_g_ompkernel[k]
                         * sJL[factors_indL] * gVPL[b_ind];
          op2R[c_ind] += factorR[i] * mDR[a_ind] * gaussW_g_ompkernel[k]
                         * sJR[factors_indR] * gVPR[b_ind];
        }
      }
    }

    double tauL[7];
    double tauR[7];
    double maxL = 0.0;
    double maxR = 0.0;
    for(int i = 0; i < 7; i++) {
      int indL = edgeL * 7 + i;
      int indR;
      if(reverse)
        indR = edgeR * 7 + 6 - i;
      else
        indR = edgeR * 7 + i;
      tauL[i] = 10 * 0.5 * 5 * 6 * fmax(*hL * gFactorL[indL], *hR * gFactorR[indR]);
      if(maxL < tauL[i]) {
        maxL = tauL[i];
      }
    }
    for(int i = 0; i < 7; i++) {
      int indL;
      int indR = edgeR * 7 + i;
      if(reverse)
        indL = edgeL * 7 + 6 - i;
      else
        indL = edgeL * 7 + i;
      tauR[i] = 10 * 0.5 * 5 * 6 * fmax(*hL * gFactorL[indL], *hR * gFactorR[indR]);
      if(maxR < tauR[i]) {
        maxR = tauR[i];
      }
    }

    for(int i = 0; i < 7; i++) {
      tauL[i] = maxL;
      tauR[i] = maxR;
    }



    for(int i = 0; i < 15; i++) {
      for(int j = 0; j < 15; j++) {
        int c_ind = i * 15 + j;
        for(int k = 0; k < 7; k++) {

          int b_ind = k * 15 + j;

          int ind = i * 7 + k;
          int a_ind = ((ind * 15) % (15 * 7)) + (ind / 7);

          int factors_indL = edgeL * 7 + k;
          int factors_indR = edgeR * 7 + k;

          op1L[c_ind] += gVML[a_ind] * gaussW_g_ompkernel[k] * sJL[factors_indL]
                         * tauL[k] * gVML[b_ind];
          op1R[c_ind] += gVMR[a_ind] * gaussW_g_ompkernel[k] * sJR[factors_indR]
                         * tauR[k] * gVMR[b_ind];

          op2L[c_ind] += -gVML[a_ind] * gaussW_g_ompkernel[k] * sJL[factors_indL]
                         * tauL[k] * gVPL[b_ind];
          op2R[c_ind] += -gVMR[a_ind] * gaussW_g_ompkernel[k] * sJR[factors_indR]
                         * tauR[k] * gVPR[b_ind];
        }
      }
    }
    //end inline func
  }

}
