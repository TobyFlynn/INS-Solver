//
// auto-generated by op2.py
//

//user function
__device__ void poisson_op2_gpu( const int *edgeNum, const bool *rev,
                        const double *mD0L, const double *mD0R,
                        const double *mD1L, const double *mD1R,
                        const double *mD2L, const double *mD2R,
                        const double *pD0L, const double *pD0R,
                        const double *pD1L, const double *pD1R,
                        const double *pD2L, const double *pD2R,
                        const double *gVP0L, const double *gVP0R,
                        const double *gVP1L, const double *gVP1R,
                        const double *gVP2L, const double *gVP2R,
                        const double *sJL, const double *sJR,
                        const double *hL, const double *hR,
                        const double *gFactorL, const double *gFactorR,
                        const double *factorL, const double *factorR,
                        double *op1L, double *op1R,
                        double *op2L, double *op2R) {

  int edgeL = edgeNum[0];
  int edgeR = edgeNum[1];
  bool reverse = *rev;


  const double *mDL, *mDR, *pDL, *pDR, *gVML, *gVMR, *gVPL, *gVPR;
  if(edgeL == 0) {
    mDL  = mD0L;
    pDL  = pD0L;
    gVML = gFInterp0_g_cuda;
    gVPL = gVP0L;
  } else if(edgeL == 1) {
    mDL  = mD1L;
    pDL  = pD1L;
    gVML = gFInterp1_g_cuda;
    gVPL = gVP1L;
  } else {
    mDL  = mD2L;
    pDL  = pD2L;
    gVML = gFInterp2_g_cuda;
    gVPL = gVP2L;
  }

  if(edgeR == 0) {
    mDR  = mD0R;
    pDR  = pD0R;
    gVMR = gFInterp0_g_cuda;
    gVPR = gVP0R;
  } else if(edgeR == 1) {
    mDR  = mD1R;
    pDR  = pD1R;
    gVMR = gFInterp1_g_cuda;
    gVPR = gVP1R;
  } else {
    mDR  = mD2R;
    pDR  = pD2R;
    gVMR = gFInterp2_g_cuda;
    gVPR = gVP2R;
  }



  for(int i = 0; i < 6; i++) {
    for(int j = 0; j < 6; j++) {
      int c_ind = i * 6 + j;
      op2L[c_ind] = 0.0;
      op2R[c_ind] = 0.0;
      for(int k = 0; k < 4; k++) {

        int b_ind = k * 6 + j;

        int ind = i * 4 + k;
        int a_ind = ((ind * 6) % (6 * 4)) + (ind / 4);


        int factors_indL = edgeL * 4 + k;
        int factors_indR = edgeR * 4 + k;
        int factors_indLR;
        int factors_indRR;
        if(reverse) {
          factors_indLR = edgeL * 4 + 4 - 1 - k;
          factors_indRR = edgeR * 4 + 4 - 1 - k;
        } else {
          factors_indLR = edgeL * 4 + k;
          factors_indRR = edgeR * 4 + k;
        }

        op1L[c_ind] += -0.5 * gVML[a_ind] * gaussW_g_cuda[k] * sJL[factors_indL]
                       * gFactorL[factors_indL] * mDL[b_ind];
        op1R[c_ind] += -0.5 * gVMR[a_ind] * gaussW_g_cuda[k] * sJR[factors_indR]
                       * gFactorR[factors_indR] * mDR[b_ind];

        op2L[c_ind] += -0.5 * gVML[a_ind] * gaussW_g_cuda[k] * sJL[factors_indL]
                       * gFactorR[factors_indRR] * pDL[b_ind];
        op2R[c_ind] += -0.5 * gVMR[a_ind] * gaussW_g_cuda[k] * sJR[factors_indR]
                       * gFactorL[factors_indLR] * pDR[b_ind];
      }
    }
  }



  for(int i = 0; i < 6; i++) {
    for(int j = 0; j < 6; j++) {
      int c_ind = i * 6 + j;
      for(int k = 0; k < 4; k++) {

        int b_ind = k * 6 + j;

        int ind = i * 4 + k;
        int a_ind = ((ind * 6) % (6 * 4)) + (ind / 4);

        int factors_indL = edgeL * 4 + k;
        int factors_indR = edgeR * 4 + k;

        op1L[c_ind] += -factorL[i] * mDL[a_ind] * gaussW_g_cuda[k]
                       * sJL[factors_indL] * gVML[b_ind];
        op1R[c_ind] += -factorR[i] * mDR[a_ind] * gaussW_g_cuda[k]
                       * sJR[factors_indR] * gVMR[b_ind];

        op2L[c_ind] += factorL[i] * mDL[a_ind] * gaussW_g_cuda[k]
                       * sJL[factors_indL] * gVPL[b_ind];
        op2R[c_ind] += factorR[i] * mDR[a_ind] * gaussW_g_cuda[k]
                       * sJR[factors_indR] * gVPR[b_ind];









      }
    }
  }

  double tauL[4];
  double tauR[4];
  double maxL = 0.0;
  double maxR = 0.0;
  for(int i = 0; i < 4; i++) {
    int indL = edgeL * 4 + i;
    int indR;
    if(reverse)
      indR = edgeR * 4 + 4 - 1 - i;
    else
      indR = edgeR * 4 + i;
    tauL[i] = 100 * 0.5 * 5 * 6 * fmax(*hL * gFactorL[indL], *hR * gFactorR[indR]);

    if(maxL < tauL[i]) {
      maxL = tauL[i];
    }
  }
  for(int i = 0; i < 4; i++) {
    int indL;
    int indR = edgeR * 4 + i;
    if(reverse)
      indL = edgeL * 4 + 4 - 1 - i;
    else
      indL = edgeL * 4 + i;
    tauR[i] = 100 * 0.5 * 5 * 6 * fmax(*hL * gFactorL[indL], *hR * gFactorR[indR]);

    if(maxR < tauR[i]) {
      maxR = tauR[i];
    }
  }

  for(int i = 0; i < 4; i++) {
    tauL[i] = maxL;
    tauR[i] = maxR;
  }



  for(int i = 0; i < 6; i++) {
    for(int j = 0; j < 6; j++) {
      int c_ind = i * 6 + j;
      for(int k = 0; k < 4; k++) {

        int b_ind = k * 6 + j;

        int ind = i * 4 + k;
        int a_ind = ((ind * 6) % (6 * 4)) + (ind / 4);

        int factors_indL = edgeL * 4 + k;
        int factors_indR = edgeR * 4 + k;

        op1L[c_ind] += gVML[a_ind] * gaussW_g_cuda[k] * sJL[factors_indL]
                       * tauL[k] * gVML[b_ind];
        op1R[c_ind] += gVMR[a_ind] * gaussW_g_cuda[k] * sJR[factors_indR]
                       * tauR[k] * gVMR[b_ind];

        op2L[c_ind] += -gVML[a_ind] * gaussW_g_cuda[k] * sJL[factors_indL]
                       * tauL[k] * gVPL[b_ind];
        op2R[c_ind] += -gVMR[a_ind] * gaussW_g_cuda[k] * sJR[factors_indR]
                       * tauR[k] * gVPR[b_ind];
      }
    }
  }

}

// CUDA kernel function
__global__ void op_cuda_poisson_op2(
  const double *__restrict ind_arg0,
  const double *__restrict ind_arg1,
  const double *__restrict ind_arg2,
  const double *__restrict ind_arg3,
  const double *__restrict ind_arg4,
  const double *__restrict ind_arg5,
  const double *__restrict ind_arg6,
  const double *__restrict ind_arg7,
  const double *__restrict ind_arg8,
  const double *__restrict ind_arg9,
  const double *__restrict ind_arg10,
  const double *__restrict ind_arg11,
  const double *__restrict ind_arg12,
  double *__restrict ind_arg13,
  const int *__restrict opDat2Map,
  const int *__restrict arg0,
  const bool *__restrict arg1,
  double *arg30,
  double *arg31,
  int start,
  int end,
  int   set_size) {
  int tid = threadIdx.x + blockIdx.x * blockDim.x;
  if (tid + start < end) {
    int n = tid + start;
    //initialise local variables
    double arg28_l[36];
    for ( int d=0; d<36; d++ ){
      arg28_l[d] = ZERO_double;
    }
    double arg29_l[36];
    for ( int d=0; d<36; d++ ){
      arg29_l[d] = ZERO_double;
    }
    int map2idx;
    int map3idx;
    map2idx = opDat2Map[n + set_size * 0];
    map3idx = opDat2Map[n + set_size * 1];

    //user-supplied kernel call
    poisson_op2_gpu(arg0+n*2,
                arg1+n*1,
                ind_arg0+map2idx*24,
                ind_arg0+map3idx*24,
                ind_arg1+map2idx*24,
                ind_arg1+map3idx*24,
                ind_arg2+map2idx*24,
                ind_arg2+map3idx*24,
                ind_arg3+map2idx*24,
                ind_arg3+map3idx*24,
                ind_arg4+map2idx*24,
                ind_arg4+map3idx*24,
                ind_arg5+map2idx*24,
                ind_arg5+map3idx*24,
                ind_arg6+map2idx*24,
                ind_arg6+map3idx*24,
                ind_arg7+map2idx*24,
                ind_arg7+map3idx*24,
                ind_arg8+map2idx*24,
                ind_arg8+map3idx*24,
                ind_arg9+map2idx*12,
                ind_arg9+map3idx*12,
                ind_arg10+map2idx*1,
                ind_arg10+map3idx*1,
                ind_arg11+map2idx*12,
                ind_arg11+map3idx*12,
                ind_arg12+map2idx*6,
                ind_arg12+map3idx*6,
                arg28_l,
                arg29_l,
                arg30+n*36,
                arg31+n*36);
    atomicAdd(&ind_arg13[0+map2idx*36],arg28_l[0]);
    atomicAdd(&ind_arg13[1+map2idx*36],arg28_l[1]);
    atomicAdd(&ind_arg13[2+map2idx*36],arg28_l[2]);
    atomicAdd(&ind_arg13[3+map2idx*36],arg28_l[3]);
    atomicAdd(&ind_arg13[4+map2idx*36],arg28_l[4]);
    atomicAdd(&ind_arg13[5+map2idx*36],arg28_l[5]);
    atomicAdd(&ind_arg13[6+map2idx*36],arg28_l[6]);
    atomicAdd(&ind_arg13[7+map2idx*36],arg28_l[7]);
    atomicAdd(&ind_arg13[8+map2idx*36],arg28_l[8]);
    atomicAdd(&ind_arg13[9+map2idx*36],arg28_l[9]);
    atomicAdd(&ind_arg13[10+map2idx*36],arg28_l[10]);
    atomicAdd(&ind_arg13[11+map2idx*36],arg28_l[11]);
    atomicAdd(&ind_arg13[12+map2idx*36],arg28_l[12]);
    atomicAdd(&ind_arg13[13+map2idx*36],arg28_l[13]);
    atomicAdd(&ind_arg13[14+map2idx*36],arg28_l[14]);
    atomicAdd(&ind_arg13[15+map2idx*36],arg28_l[15]);
    atomicAdd(&ind_arg13[16+map2idx*36],arg28_l[16]);
    atomicAdd(&ind_arg13[17+map2idx*36],arg28_l[17]);
    atomicAdd(&ind_arg13[18+map2idx*36],arg28_l[18]);
    atomicAdd(&ind_arg13[19+map2idx*36],arg28_l[19]);
    atomicAdd(&ind_arg13[20+map2idx*36],arg28_l[20]);
    atomicAdd(&ind_arg13[21+map2idx*36],arg28_l[21]);
    atomicAdd(&ind_arg13[22+map2idx*36],arg28_l[22]);
    atomicAdd(&ind_arg13[23+map2idx*36],arg28_l[23]);
    atomicAdd(&ind_arg13[24+map2idx*36],arg28_l[24]);
    atomicAdd(&ind_arg13[25+map2idx*36],arg28_l[25]);
    atomicAdd(&ind_arg13[26+map2idx*36],arg28_l[26]);
    atomicAdd(&ind_arg13[27+map2idx*36],arg28_l[27]);
    atomicAdd(&ind_arg13[28+map2idx*36],arg28_l[28]);
    atomicAdd(&ind_arg13[29+map2idx*36],arg28_l[29]);
    atomicAdd(&ind_arg13[30+map2idx*36],arg28_l[30]);
    atomicAdd(&ind_arg13[31+map2idx*36],arg28_l[31]);
    atomicAdd(&ind_arg13[32+map2idx*36],arg28_l[32]);
    atomicAdd(&ind_arg13[33+map2idx*36],arg28_l[33]);
    atomicAdd(&ind_arg13[34+map2idx*36],arg28_l[34]);
    atomicAdd(&ind_arg13[35+map2idx*36],arg28_l[35]);
    atomicAdd(&ind_arg13[0+map3idx*36],arg29_l[0]);
    atomicAdd(&ind_arg13[1+map3idx*36],arg29_l[1]);
    atomicAdd(&ind_arg13[2+map3idx*36],arg29_l[2]);
    atomicAdd(&ind_arg13[3+map3idx*36],arg29_l[3]);
    atomicAdd(&ind_arg13[4+map3idx*36],arg29_l[4]);
    atomicAdd(&ind_arg13[5+map3idx*36],arg29_l[5]);
    atomicAdd(&ind_arg13[6+map3idx*36],arg29_l[6]);
    atomicAdd(&ind_arg13[7+map3idx*36],arg29_l[7]);
    atomicAdd(&ind_arg13[8+map3idx*36],arg29_l[8]);
    atomicAdd(&ind_arg13[9+map3idx*36],arg29_l[9]);
    atomicAdd(&ind_arg13[10+map3idx*36],arg29_l[10]);
    atomicAdd(&ind_arg13[11+map3idx*36],arg29_l[11]);
    atomicAdd(&ind_arg13[12+map3idx*36],arg29_l[12]);
    atomicAdd(&ind_arg13[13+map3idx*36],arg29_l[13]);
    atomicAdd(&ind_arg13[14+map3idx*36],arg29_l[14]);
    atomicAdd(&ind_arg13[15+map3idx*36],arg29_l[15]);
    atomicAdd(&ind_arg13[16+map3idx*36],arg29_l[16]);
    atomicAdd(&ind_arg13[17+map3idx*36],arg29_l[17]);
    atomicAdd(&ind_arg13[18+map3idx*36],arg29_l[18]);
    atomicAdd(&ind_arg13[19+map3idx*36],arg29_l[19]);
    atomicAdd(&ind_arg13[20+map3idx*36],arg29_l[20]);
    atomicAdd(&ind_arg13[21+map3idx*36],arg29_l[21]);
    atomicAdd(&ind_arg13[22+map3idx*36],arg29_l[22]);
    atomicAdd(&ind_arg13[23+map3idx*36],arg29_l[23]);
    atomicAdd(&ind_arg13[24+map3idx*36],arg29_l[24]);
    atomicAdd(&ind_arg13[25+map3idx*36],arg29_l[25]);
    atomicAdd(&ind_arg13[26+map3idx*36],arg29_l[26]);
    atomicAdd(&ind_arg13[27+map3idx*36],arg29_l[27]);
    atomicAdd(&ind_arg13[28+map3idx*36],arg29_l[28]);
    atomicAdd(&ind_arg13[29+map3idx*36],arg29_l[29]);
    atomicAdd(&ind_arg13[30+map3idx*36],arg29_l[30]);
    atomicAdd(&ind_arg13[31+map3idx*36],arg29_l[31]);
    atomicAdd(&ind_arg13[32+map3idx*36],arg29_l[32]);
    atomicAdd(&ind_arg13[33+map3idx*36],arg29_l[33]);
    atomicAdd(&ind_arg13[34+map3idx*36],arg29_l[34]);
    atomicAdd(&ind_arg13[35+map3idx*36],arg29_l[35]);
  }
}


//host stub function
void op_par_loop_poisson_op2(char const *name, op_set set,
  op_arg arg0,
  op_arg arg1,
  op_arg arg2,
  op_arg arg3,
  op_arg arg4,
  op_arg arg5,
  op_arg arg6,
  op_arg arg7,
  op_arg arg8,
  op_arg arg9,
  op_arg arg10,
  op_arg arg11,
  op_arg arg12,
  op_arg arg13,
  op_arg arg14,
  op_arg arg15,
  op_arg arg16,
  op_arg arg17,
  op_arg arg18,
  op_arg arg19,
  op_arg arg20,
  op_arg arg21,
  op_arg arg22,
  op_arg arg23,
  op_arg arg24,
  op_arg arg25,
  op_arg arg26,
  op_arg arg27,
  op_arg arg28,
  op_arg arg29,
  op_arg arg30,
  op_arg arg31){

  int nargs = 32;
  op_arg args[32];

  args[0] = arg0;
  args[1] = arg1;
  args[2] = arg2;
  args[3] = arg3;
  args[4] = arg4;
  args[5] = arg5;
  args[6] = arg6;
  args[7] = arg7;
  args[8] = arg8;
  args[9] = arg9;
  args[10] = arg10;
  args[11] = arg11;
  args[12] = arg12;
  args[13] = arg13;
  args[14] = arg14;
  args[15] = arg15;
  args[16] = arg16;
  args[17] = arg17;
  args[18] = arg18;
  args[19] = arg19;
  args[20] = arg20;
  args[21] = arg21;
  args[22] = arg22;
  args[23] = arg23;
  args[24] = arg24;
  args[25] = arg25;
  args[26] = arg26;
  args[27] = arg27;
  args[28] = arg28;
  args[29] = arg29;
  args[30] = arg30;
  args[31] = arg31;

  // initialise timers
  double cpu_t1, cpu_t2, wall_t1, wall_t2;
  op_timing_realloc(20);
  op_timers_core(&cpu_t1, &wall_t1);
  OP_kernels[20].name      = name;
  OP_kernels[20].count    += 1;


  int    ninds   = 14;
  int    inds[32] = {-1,-1,0,0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13,-1,-1};

  if (OP_diags>2) {
    printf(" kernel routine with indirection: poisson_op2\n");
  }
  int set_size = op_mpi_halo_exchanges_grouped(set, nargs, args, 2);
  if (set_size > 0) {

    //set CUDA execution parameters
    #ifdef OP_BLOCK_SIZE_20
      int nthread = OP_BLOCK_SIZE_20;
    #else
      int nthread = OP_block_size;
    #endif

    for ( int round=0; round<2; round++ ){
      if (round==1) {
        op_mpi_wait_all_grouped(nargs, args, 2);
      }
      int start = round==0 ? 0 : set->core_size;
      int end = round==0 ? set->core_size : set->size + set->exec_size;
      if (end-start>0) {
        int nblocks = (end-start-1)/nthread+1;
        op_cuda_poisson_op2<<<nblocks,nthread>>>(
        (double *)arg2.data_d,
        (double *)arg4.data_d,
        (double *)arg6.data_d,
        (double *)arg8.data_d,
        (double *)arg10.data_d,
        (double *)arg12.data_d,
        (double *)arg14.data_d,
        (double *)arg16.data_d,
        (double *)arg18.data_d,
        (double *)arg20.data_d,
        (double *)arg22.data_d,
        (double *)arg24.data_d,
        (double *)arg26.data_d,
        (double *)arg28.data_d,
        arg2.map_data_d,
        (int*)arg0.data_d,
        (bool*)arg1.data_d,
        (double*)arg30.data_d,
        (double*)arg31.data_d,
        start,end,set->size+set->exec_size);
      }
    }
  }
  op_mpi_set_dirtybit_cuda(nargs, args);
  cutilSafeCall(cudaDeviceSynchronize());
  //update kernel record
  op_timers_core(&cpu_t2, &wall_t2);
  OP_kernels[20].time     += wall_t2 - wall_t1;
}
